<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Vite 初探 | Arvin's Blogs</title><meta name="keywords" content="blog"><meta name="author" content="Arvin Huang"><meta name="copyright" content="Arvin Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Vite是什么？Vite是一种新型的前端打包构建工具，由Vue的作者尤雨溪开发。 Vite的主要组成部分：  一个开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）。 一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源。   浏览器兼容： ​    默认的构建目标浏览器是能 在 scrip">
<meta property="og:type" content="article">
<meta property="og:title" content="Vite 初探">
<meta property="og:url" content="https://hello-hc.github.io/2021/06/04/vite/vite/">
<meta property="og:site_name" content="Arvin&#39;s Blogs">
<meta property="og:description" content="一、Vite是什么？Vite是一种新型的前端打包构建工具，由Vue的作者尤雨溪开发。 Vite的主要组成部分：  一个开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）。 一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源。   浏览器兼容： ​    默认的构建目标浏览器是能 在 scrip">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hello-hc.github.io/images/img_05.jpg">
<meta property="article:published_time" content="2021-06-04T02:00:55.000Z">
<meta property="article:modified_time" content="2021-07-28T15:39:51.866Z">
<meta property="article:author" content="Arvin Huang">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hello-hc.github.io/images/img_05.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://hello-hc.github.io/2021/06/04/vite/vite/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vite 初探',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-28 23:39:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/img_05.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Arvin's Blogs</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Vite 初探</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-04T02:00:55.000Z" title="发表于 2021-06-04 10:00:55">2021-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-28T15:39:51.866Z" title="更新于 2021-07-28 23:39:51">2021-07-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Vite 初探"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一、Vite是什么？"><a href="#一、Vite是什么？" class="headerlink" title="一、Vite是什么？"></a>一、Vite是什么？</h2><p><strong>Vite是一种新型的前端打包构建工具，由Vue的作者尤雨溪开发。</strong></p>
<p>Vite的主要组成部分：</p>
<ol>
<li>一个开发服务器，它基于 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">原生 ES 模块</a> 提供了 <a target="_blank" rel="noopener" href="https://cn.vitejs.dev/guide/features.html">丰富的内建功能</a>，如速度快到惊人的 <a target="_blank" rel="noopener" href="https://cn.vitejs.dev/guide/features.html#hot-module-replacement">模块热更新（HMR）</a>。</li>
<li>一套构建指令，它使用 <a target="_blank" rel="noopener" href="https://rollupjs.org/">Rollup</a> 打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源。</li>
</ol>
<blockquote>
<p>浏览器兼容：</p>
<p>​    默认的构建目标浏览器是能 <a target="_blank" rel="noopener" href="https://caniuse.com/es6-module">在 script 标签上支持原生 ESM</a> 和 <a target="_blank" rel="noopener" href="https://caniuse.com/es6-module-dynamic-import">原生 ESM 动态导入</a>。</p>
<p>​    传统浏览器可以通过官方插件 <a target="_blank" rel="noopener" href="https://github.com/vitejs/vite/tree/main/packages/plugin-legacy">@vitejs/plugin-legacy</a> 支持 —— 查看 <a target="_blank" rel="noopener" href="https://cn.vitejs.dev/guide/build.html">构建生产版本</a> 章节获取更多细节。</p>
</blockquote>
<p>PS：2021-05-22的VueConf2021线上开发者大会其中有一个关于Vite的分享：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/tjIM1ayu_lrrVfpsk4slag">https://mp.weixin.qq.com/s/tjIM1ayu_lrrVfpsk4slag</a></p>
<h2 id="二、为什么会出现Vite，换言之，为什么会出现打包构建工具？"><a href="#二、为什么会出现Vite，换言之，为什么会出现打包构建工具？" class="headerlink" title="二、为什么会出现Vite，换言之，为什么会出现打包构建工具？"></a>二、为什么会出现Vite，换言之，为什么会出现打包构建工具？</h2><p><strong>打包构建工具出现的原因：</strong></p>
<p>由于前端项目的复杂度升级，代码规范和管理就必须要同步提升。</p>
<blockquote>
<p>从代码规范层面出发，服务端选择了Common JS规范，客户端选择了AMD规范；</p>
<p>从语言层面出发，选择了ES Modules规范（自ES6提出）</p>
</blockquote>
<p>模块化可以帮助我们更好的解决复杂应用开发过程中的代码组织问题，但是随着模块化思想的深入，前端应用又产生了新的问题，比如：</p>
<ol>
<li>ES Modules模块系统的环境兼容问题</li>
<li>零散的模块文件导致的频繁网络请求发送</li>
<li>模块化发散问题，HTML、CSS等资源文件也可能会模块化</li>
<li>…</li>
</ol>
<p>模块化对于开发过程而言是必要的。由此我们就需要在模块化的基础上去引入更好的方案和工具去解决上述的问题，因此，以Webpack为首的打包工具就出现了。</p>
<p><strong>简言之，就是：项目越复杂 —-&gt; 模块化规范出现 —-&gt; 产生模块化的问题 —-&gt; 打包构建工具出现</strong></p>
<p>那么，问题来了，既然已经有了Webpack，为什么又出现了一个Vite？</p>
<p><strong>Vite出现的原因：</strong></p>
<p>我们先来看一下下面分别介绍Webpack和Vite的打包流程图，看看我们能从中得出什么结论？</p>
<p>Webpack打包构建流程图示：</p>
<p><img src="./webpack.png" alt="webpack"></p>
<p>Vite打包构建流程图示：</p>
<p><img src="./vite-bundler.png" alt="vite-bundle"></p>
<p>Vite原理图：</p>
<p><img src="./vite-esm.png" alt="vite-esm"></p>
<p>由上述图示，我们可以知道</p>
<p><strong>Webpack打包过程：</strong></p>
<ol>
<li>识别入口文件</li>
<li>通过逐层识别模块依赖。（AMD、CommonJS、ES Modules，Webpack都会对其进行分析，来获取代码的依赖）</li>
<li>分析代码，转换代码，编译代码、输出代码</li>
<li>形成最终打包构建后的代码</li>
</ol>
<p><strong>Vite打包过程：</strong></p>
<ol>
<li><p>当我们声明一个script标签类型为module时。如<code>&lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;</code></p>
<blockquote>
<p>模块仅仅就是普通的含有js代码的文件而已，我们可以用<strong>import</strong>和<strong>export</strong>关键字对变量,对象的导出和导入，而这个机制在高级浏览器已经完全实现了。</p>
<p>MDN: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script</a></p>
</blockquote>
</li>
<li><p>当浏览器解析保留了模块关键字的代码，从而会导致HTTP请求，Vite通过koa拦截了这些请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://localhost:3000/src/main.js请求main.js文件：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Routes <span class="keyword">from</span> <span class="string">&#x27;./routes.jsx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./styles/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Routes</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>浏览器请求到了main.js文件，检测到内部含有import引入的包，又会对其内部的 import 引用发起 HTTP 请求获取模块的内容文件</p>
<blockquote>
<p>如：GET <a target="_blank" rel="noopener" href="http://localhost:3000/@modules/react">http://localhost:3000/@modules/react</a></p>
<p>如：GET <a target="_blank" rel="noopener" href="http://localhost:3000/src/routes.jsx">http://localhost:3000/src/routes.jsx</a></p>
</blockquote>
</li>
<li><p>通过劫持浏览器的这些请求，并在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再返回给浏览器，Vite整个过程中没有对文件进行打包编译</p>
</li>
</ol>
<p><strong>这实际上就是以ES Modules的方式服务源码，让浏览器接管了打包程序的部分工作（Vite只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入的代码，即只在当前屏幕页面实际使用时才会被处理）</strong></p>
<p><strong>总的来说就是：通过Koa服务，实现了按需读取文件，省掉了打包步骤，以此来提升项目启动速度，这中间包含了一系列的处理，诸如解析代码内容、静态文件读取、浏览器新特性实践等等。Vite最创意的地方就是利用了浏览器的高级特性让开发体验变得更好</strong></p>
<blockquote>
<p> Webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包后的结果；而Vite则是不打包文件代码，直接启动开发服务器，请求哪个模块，那么就会对哪个模块进行实时编译。（<strong>简言之，就是快速冷启动，按需编译</strong>）</p>
</blockquote>
<p>从这个过程我们可以发现，它们之间的优缺点。</p>
<p><strong>Vite较Webpack的优势：</strong></p>
<ul>
<li><p>其一，当冷启动开发服务器时，Webpack会基于打包器的方式是在提供服务前去急切地抓取和构建你的整个应用；而Vite通过一开始将应用中的模块区分为“依赖”和“源码”两类，并通过按需加载，改进了开发服务器的启动时间</p>
<blockquote>
<p>“依赖”：大多数为纯JavaScript，并且在开发时不会变动。（一些较大的依赖，如组件库，处理的代价也很高。依赖通常也会以某些方式被拆分到大量小模块中。）</p>
<p>”源码“：通常包含一些并非直接是JavaScript的文件。需要转换（比如JSX、CSS等文件），并且可能时常被编辑。同时，也并非所有的源码都需要同时被加载。（比如基于路由拆分的代码模块）。</p>
<p>（Vite先来打包问题，只启动一台静态页面的服务器，对文件代码不打包，服务器会根据客户端的请求加载不同的模块处理，实现真正的按需加载）</p>
</blockquote>
</li>
<li><p>其二，Webpack和Vite实现的语言不同。Webpack由node.js实现；Vite由Go语言实现（打包器预构建依赖比node.js快得多）</p>
</li>
<li><p>其三，Webpack热更新效率相比Vite热更新效率低下。</p>
<blockquote>
<p>Webpack</p>
<p>当基于打包器启动时，编辑文件后将重新构建文件本身。显然我们不应该重新构建整个包，因为这样更新速度会随着应用体积增长而直线下降</p>
<p>一些打包器的开发服务器将构建内容存入内存，这样它们只需要在文件更改时使模块图的一部分失活，但它也仍需要整个重新构建并重载页面。这样代价很高，并且重新加载页面会消除应用的当前状态，所以打包器支持了动态模块热重载（HMR）：允许一个模块“热替换”它自己，而对页面其余部分没有影响。这大大改进了开发体验。然而，在实践中我们发现，即使是HMR更新速度也会随着应用规模的增长而显著下降。</p>
<p>（重新以当前修改的文件为入口重新打包build包，所有涉及到的依赖也都会被重新加载一次）</p>
<p>Vite</p>
<p>在Vite中，HMR是在原生ES Modules上执行的。当编辑一个文件时，<strong>Vite只需要精确地使已编辑的模块与其最近的HMR边界之间的链失效（大多数的时候只需要模块本身），使HMR更新始终快速，无论应用的大小</strong></p>
<p>同时利用HTTP头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据304 Not Modified进行协商缓存，而依赖模块请求则会通过Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。</p>
<p>（采用立即编译当前修改文件的办法。同时Vite还会使用缓存机制（http缓存 =&gt; Vite内置缓存），加载更新后的文件内容）</p>
<p>虽然Vite和Webpack的HMR实现机制是一样的，都是通过客户端和服务端建立socket连接，服务端有变化则通知客户端做出改变，但是他们本质上构建的方式决定了它们的效率和速度。</p>
</blockquote>
</li>
</ul>
<p><strong>Vite较Webpack的劣势：</strong></p>
<ul>
<li><p>生态不如Webpack，尤其Webpack的loader和plugin十分的丰富</p>
</li>
<li><p>Vite目前生产环境（production）的构建，采用的Rollup</p>
<blockquote>
<p>不使用ES Build的原因是：ES Build目前对于代码分割和CSS处理方面不太友好</p>
<p>有兴趣的可以自行查阅资料</p>
</blockquote>
</li>
<li><p>Vite出道时间短，还没有广泛的使用，可能不是很成熟</p>
</li>
</ul>
<p><strong>esbuild</strong></p>
<p>我们当前用于 Web 的构建工具比它们可能的速度慢 10-100 倍。esbuild bundler 项目的主要目标是开创一个构建工具性能的新时代，并在此过程中创建一个易于使用的现代 bundler。</p>
<p>主要特点：</p>
<ul>
<li>无需缓存即可达到极速</li>
<li>ES6 和 CommonJS 模块</li>
<li>ES6 模块的 Tree shaking</li>
<li>用于 JavaScript 和 Go的<a target="_blank" rel="noopener" href="https://esbuild.github.io/api/">API</a></li>
<li><a target="_blank" rel="noopener" href="https://esbuild.github.io/content-types/#typescript">TypeScript</a>和<a target="_blank" rel="noopener" href="https://esbuild.github.io/content-types/#jsx">JSX</a>语法</li>
<li><a target="_blank" rel="noopener" href="https://esbuild.github.io/api/#sourcemap">Source maps</a></li>
<li><a target="_blank" rel="noopener" href="https://esbuild.github.io/api/#minify">Minification 压缩</a></li>
<li><a target="_blank" rel="noopener" href="https://esbuild.github.io/plugins/">Plugins 插件</a></li>
</ul>
<p><img src="./vite-esbuild.png" alt="vite-esbuild"></p>
<p><strong>功能对比</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Vite 2.x</th>
<th>Webpack 5.x</th>
</tr>
</thead>
<tbody><tr>
<td>支持Vue2</td>
<td>非官方支持<br /><a target="_blank" rel="noopener" href="https://github.com/underfin/vite-plugin-vue2">https://github.com/underfin/vite-plugin-vue2</a></td>
<td>支持：vue-loader@^15.0.0</td>
</tr>
<tr>
<td>支持Vue3</td>
<td>支持</td>
<td>支持：vue-loader@^16.0.0<br /><a target="_blank" rel="noopener" href="https://github.com/Jamie-Yang/vue3-boilerplate">https://github.com/Jamie-Yang/vue3-boilerplate</a></td>
</tr>
<tr>
<td>支持React</td>
<td>支持</td>
<td>支持：babel-loader</td>
</tr>
<tr>
<td>支持TypeScript</td>
<td>支持：ES Build（默认无类型检查）</td>
<td>支持：ts-loader</td>
</tr>
<tr>
<td>支持CSS预处理器</td>
<td>支持：<br /><a target="_blank" rel="noopener" href="https://vitejs.dev/guide/features.html#css-modules">https://vitejs.dev/guide/features.html#css-modules</a></td>
<td>支持：<br /><a target="_blank" rel="noopener" href="https://vue-loader.vuejs.org/guide/css-modules.html">https://vue-loader.vuejs.org/guide/css-modules.html</a></td>
</tr>
<tr>
<td>支持静态文件</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>开发环境</td>
<td>no-bundle native ESM(CJS =&gt; ESM)</td>
<td>bundle(CJS/UMD/ESM)</td>
</tr>
<tr>
<td>HMR</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>生产环境</td>
<td>Rollup</td>
<td>Webpack</td>
</tr>
<tr>
<td>Node API调用能力</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p><strong>综上，Vite具有快速冷启动、按需编译、模块热更新等开发环境的优良性质</strong></p>
<h2 id="三、如何使用Vite？"><a href="#三、如何使用Vite？" class="headerlink" title="三、如何使用Vite？"></a>三、如何使用Vite？</h2><h3 id="1-项目搭建"><a href="#1-项目搭建" class="headerlink" title="1. 项目搭建"></a>1. 项目搭建</h3><blockquote>
<p>兼容性注意：Vite需要Node.js版本 &gt;=12.0.0</p>
</blockquote>
<h4 id="搭建Vite项目的方式："><a href="#搭建Vite项目的方式：" class="headerlink" title="搭建Vite项目的方式："></a>搭建Vite项目的方式：</h4><ul>
<li><p>脚手架搭建</p>
<ul>
<li>通过<code>npm init @vitejs/app</code>安装的方式</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里我的node版本为14.x，npm版本为6.x。因此我就直接在终端执行</span></span><br><span class="line">npm init @vitejs/app</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后按照提示的依次输入，按回车</span></span><br><span class="line">? Project name: <span class="comment">// 你的项目名称</span></span><br><span class="line">? Select a framework: <span class="comment">// 选择语言框架，这里我们选择react</span></span><br><span class="line">❯   vanilla</span><br><span class="line">    vue</span><br><span class="line">    react</span><br><span class="line">    preact</span><br><span class="line">    lit-element</span><br><span class="line">    svelte</span><br><span class="line">? Select a variant: <span class="comment">// 选择变体，存在两种版本，js版和ts版，这里我们选择js版，即react</span></span><br><span class="line">❯   react</span><br><span class="line">    react-ts</span><br><span class="line"></span><br><span class="line">Scaffolding project <span class="keyword">in</span> /Users/arvin/Desktop/vite/init-vite-app... <span class="comment">// 项目文件位置路径</span></span><br><span class="line"></span><br><span class="line">Done. Now run: <span class="comment">// 创建完毕，依次执行如下命令</span></span><br><span class="line"></span><br><span class="line">  cd init-vite-app</span><br><span class="line">  npm install</span><br><span class="line">  npm run dev</span><br></pre></td></tr></table></figure>

<ul>
<li>通过直接赋予预设模版的方式<code>npm init @vitejs/app my-vue-app --template vue</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm init @vitejs/app 项目名称 --template 预设模版框架名称</span></span><br><span class="line"></span><br><span class="line">npm init @vitejs/app init-template-vite-app --template react</span><br><span class="line"></span><br><span class="line">Scaffolding project <span class="keyword">in</span> /Users/arvin/Desktop/vite/init-template-vite-app... <span class="comment">// 项目文件位置路径</span></span><br><span class="line"></span><br><span class="line">Done. Now run: <span class="comment">// 创建完毕，依次执行如下命令</span></span><br><span class="line"></span><br><span class="line">  cd init-template-vite-app</span><br><span class="line">  npm install</span><br><span class="line">  npm run dev</span><br></pre></td></tr></table></figure>

<p>其他预设模版详情见<a target="_blank" rel="noopener" href="https://github.com/vitejs/vite/tree/main/packages/create-app">https://github.com/vitejs/vite/tree/main/packages/create-app</a></p>
</li>
<li><p>手动创建</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建项目文件夹</span></span><br><span class="line">mkdir create-manually-vite</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入该文件夹</span></span><br><span class="line">cd create-manually-vite</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化npm</span></span><br><span class="line">npm init （手动输入package.json文件内容）</span><br><span class="line">或 </span><br><span class="line">npm init -y （直接按默认值初始化package.json文件内容）</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This utility will walk you through creating a package.json file.</span></span><br><span class="line"><span class="comment">It only covers the most common items, and tries to guess sensible defaults.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">See `npm help init` for definitive documentation on these fields</span></span><br><span class="line"><span class="comment">and exactly what they do.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Use `npm install &lt;pkg&gt;` afterwards to install a package and</span></span><br><span class="line"><span class="comment">save it as a dependency in the package.json file.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Press ^C at any time to quit.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">package name: (create-manually-vite) // 项目/模块名称，长度必须小于等于214个字符，不能以&quot;.&quot;(点)或者&quot;_&quot;(下划线)开头，不能包含大写字母。括号中为默认值，即当前文件夹名称</span></span><br><span class="line"><span class="comment">version: (1.0.0) // 项目版本，默认1.0.0</span></span><br><span class="line"><span class="comment">description: // 项目描述，是一个字符串。它可以帮助开发者在使用npm search时找到这个包</span></span><br><span class="line"><span class="comment">entry point: (index.js) // 项目执行入口文件，比如 require(‘webpack’)。就会默认加载 lib 目录下的 webpack.js 文件，如果没有设置，则默认加载项目跟目录下的 index.js 文件</span></span><br><span class="line"><span class="comment">test command: // 即stripts。执行 npm 脚本命令简写，比如 “start”: “react-scripts start”, 执行 npm start 就是运行 “react-scripts start”</span></span><br><span class="line"><span class="comment">git repository:</span></span><br><span class="line"><span class="comment">keywords: // 项目关键字，是一个字符串数组。它可以帮助人们在使用npm search时找到这个包</span></span><br><span class="line"><span class="comment">author: // 项目开发者，它的值是你在https://npmjs.org网站的有效账户名，遵循“账户名&lt;邮件&gt;”的规则，例如：zhangsan zhangsan@163.com</span></span><br><span class="line"><span class="comment">license: (ISC) // 软件授权条款，让用户知道他们的使用权利和限制。默认ISC</span></span><br><span class="line"><span class="comment">About to write to /Users/arvin/Desktop/vite/create-manually-vite/package.json:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;name&quot;: &quot;create-manually-vite&quot;,</span></span><br><span class="line"><span class="comment">  &quot;version&quot;: &quot;1.0.0&quot;,</span></span><br><span class="line"><span class="comment">  &quot;description&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="comment">  &quot;main&quot;: &quot;index.js&quot;,</span></span><br><span class="line"><span class="comment">  &quot;scripts&quot;: &#123;</span></span><br><span class="line"><span class="comment">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  &quot;author&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="comment">  &quot;license&quot;: &quot;ISC&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Is this OK? (yes)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他package.json内容的说明</span></span><br><span class="line"><span class="comment">// 详情请见npm官网：https://docs.npmjs.com/cli/v6/configuring-npm/package-json</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">private：是否私有，设置为 true 时，npm 拒绝发布。</span></span><br><span class="line"><span class="comment">bugs：bug 提交地址。</span></span><br><span class="line"><span class="comment">contributors：项目贡献者 。</span></span><br><span class="line"><span class="comment">repository：项目仓库地址。</span></span><br><span class="line"><span class="comment">homepage：项目包的官网 URL。</span></span><br><span class="line"><span class="comment">dependencies：生产环境下，项目运行所需依赖。</span></span><br><span class="line"><span class="comment">devDependencies：开发环境下，项目所需依赖。</span></span><br><span class="line"><span class="comment">bin：内部命令对应的可执行文件的路径。</span></span><br><span class="line"><span class="comment">module：是以 ES Module(也就是 ES6)模块化方式进行加载，因为早期没有 ES6 模块化方案时，都是遵循 CommonJS 规范，而 CommonJS 规范的包是以 main 的方式表示入口文件的，为了区分就新增了 module 方式，但是 ES6 模块化方案效率更高，所以会优先查看是否有 module 字段，没有才使用 main 字段。</span></span><br><span class="line"><span class="comment">eslintConfig：EsLint 检查文件配置，自动读取验证。</span></span><br><span class="line"><span class="comment">engines：项目运行的平台。</span></span><br><span class="line"><span class="comment">browserslist：供浏览器使用的版本列表。</span></span><br><span class="line"><span class="comment">style：供浏览器使用时，样式文件所在的位置；样式文件打包工具parcelify，通过它知道样式文件的打包位置。</span></span><br><span class="line"><span class="comment">files：被项目包含的文件名数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在我们安装vite</span></span><br><span class="line">npm install -D vite</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装完vite后，我们发现还没有可以打包的东西，以及我们可能想要对这个项目做一些定制化的配置，因此我们还需要一个配置文件用来配置一些我们项目中非vite默认配置的文件</span></span><br><span class="line"><span class="comment">// 那么我们执行如下操作</span></span><br><span class="line">touch vite.config.js <span class="comment">// 创建vite配置文件</span></span><br><span class="line">mkdir src <span class="comment">// 创建源文件目录</span></span><br><span class="line">touch src/index.jsx <span class="comment">// 创建项目入口文件，这里我使用index.jsx文件，创建完记得同时把package.json中的“main”入口文件修改为该文件的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行完这些后，我们可以在package.json中的脚本执行命令添加vite构建命令，比如如下：</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;vite&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 这个时候我们就可以执行npm run dev来运行期开发环境的vite服务器了，但是，如果你执行了，在浏览器打开，你就会发现，缺少了一个html模版文件</span></span><br><span class="line"><span class="comment">// 值得注意的是，与wbepack不同，vite中，默认html文件的位置既不是在src中，也不是在public静态资源文件夹下，而是直接在项目根目录下</span></span><br><span class="line"><span class="comment">// 前面我们也有讲过vite的原理，由于这个html文件在开发环境下是vite项目的入口点，因此我们需要创建这个文件</span></span><br><span class="line">touch index.html <span class="comment">// 创建开发环境下的vite入口文件</span></span><br><span class="line"><span class="comment">// 进入index.html文件中，在body中添加上js文件的引用  &lt;script src=&quot;./src/index.jsx&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">// 然后我们安装react</span></span><br><span class="line">npm install -S react</span><br><span class="line">npm isntall -S react-dom</span><br><span class="line"><span class="comment">// 然后我们在index.jsx中随便写点东西，再执行npm run dev看看有没有效果</span></span><br><span class="line"></span><br><span class="line">index.jsx</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Index = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            index.jsx</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Index</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line"></span><br><span class="line">index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Vite App&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">		// 注意：由于JSX中使用的是import模块的语法，因此，这里引入该文件，需要在script标签上添加山type=&quot;module&quot;才行</span><br><span class="line">		// 浏览器就能解析代码中的module语法</span><br><span class="line">    &lt;script type=&quot;module&quot; src=&quot;./src/index.jsx&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 通过上面的步骤，我们就可以执行npm run dev了，浏览器中就会正常显示index.jsx中的内容</span><br></pre></td></tr></table></figure>

<h3 id="2-项目文件及目录介绍"><a href="#2-项目文件及目录介绍" class="headerlink" title="2. 项目文件及目录介绍"></a>2. 项目文件及目录介绍</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码文件目录结构</span></span><br><span class="line">├── node_modules</span><br><span class="line">├── src</span><br><span class="line">    ├── App.css</span><br><span class="line">    ├── App.jsx</span><br><span class="line">    ├── favicon.svg</span><br><span class="line">    ├── index.css</span><br><span class="line">    ├── logo.svg</span><br><span class="line">    └── main.jsx</span><br><span class="line">├── .gitignore</span><br><span class="line">├── index.html</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">└── vite.config.js</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由上述可以看出，基本上与create-react-app创建出来的应用一致</span></span><br></pre></td></tr></table></figure>

<p>不同之处：</p>
<p>index.html在项目最外层而不是在public文件夹内。（有意为之：在开发服务期间Vite是一个服务器，而index.html是该Vite项目的入口文件）。</p>
<blockquote>
<p>Vite 将 <code>index.html</code> 视为源码和模块图的一部分。Vite 解析 <code>&lt;script type=&quot;module&quot; src=&quot;...&quot;&gt;</code> ，这个标签指向你的 JavaScript 源码。甚至内联引入 JavaScript 的 <code>&lt;script type=&quot;module&quot; src=&quot;...&quot;&gt;</code> 和引用 CSS 的 <code>&lt;link href&gt;</code> 也能利用 Vite 特有的功能被解析。另外，<code>index.html</code> 中的 URL 将被自动转换，因此不再需要 <code>%PUBLIC_URL%</code> 占位符了。</p>
<p>与静态HTTP服务器类似，Vite也有“根目录”的概念，即文件被提供的位置。你会看到它在整个文档中用<code>&lt;root&gt;</code>表示。源码中的绝对URL路径将以项目的“根”作为基础来解析，因此你可以像在普通的静态文件服务器上一样编写代码。Vite还能够处理依赖关系，解析处于根目录外的文件位置，这使得它即使在基于monorepo的方案中也十分有用。Vite也支持多个.html作为入口点的多页面应用模式。</p>
</blockquote>
<p>指定替代根目录：以当前工作目录作为根目录启动开发服务器。你也可以通过vite serve some/sub/dir来指定一个替代的根目录。</p>
<p><strong>命令行界面：</strong></p>
<p>在安装了Vite的项目中，可以在npm scripts中使用vite可执行文件，或者直接使用<code>npx vite</code>运行它。</p>
<p>下面是通过脚手架创建的Vite项目中默认的npm scripts:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;vite&quot;</span>, <span class="comment">// 启动开发服务器</span></span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;vite build&quot;</span>, <span class="comment">// 为生产环境构建产物</span></span><br><span class="line">    <span class="string">&quot;serve&quot;</span>: <span class="string">&quot;vite preview&quot;</span> <span class="comment">// 本地预览生产构建产物</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以指定额外的命令行选项，如 --port 或 --https。运行 npx vite --help 获取完整的命令行选项列表</span></span><br></pre></td></tr></table></figure>



<h3 id="3-项目需求"><a href="#3-项目需求" class="headerlink" title="3. 项目需求"></a>3. 项目需求</h3><p><strong>我们的项目可能会需要哪些配置呢？</strong></p>
<ol>
<li><p>浏览器兼容配置，浏览器版本以及浏览器种类的差异可能导致我们的代码在不同的浏览器或者不同的版本下显示的与预想的不同。</p>
<p><strong>(Vite 自动会生成一个轻量级的 <a target="_blank" rel="noopener" href="https://github.com/GoogleChromeLabs/dynamic-import-polyfill">动态导入 polyfill</a> 来抹平二者差异。)</strong></p>
</li>
<li><p>资源文件的处理 （<strong>Vite内置支持了JSX、less/sass/stylus…等文件，不需要另外下载loader进行解析，但是需要下载对应的预处理器，比如less，就需要npm install -D less</strong>）</p>
</li>
<li><p>自动刷新页面以及热更新</p>
</li>
<li><p>Tree Shaking（即将项目中没有用到的代码移除，缩减打包体积）</p>
</li>
<li><p>Code Splitting（即代码拆分，把代码分离到不同的bundle中，然后按需加载或并行加载这些文件，可减少加载的时间）</p>
</li>
<li><p>动态加载、预加载等</p>
</li>
</ol>
<h3 id="4-功能介绍"><a href="#4-功能介绍" class="headerlink" title="4. 功能介绍"></a>4. 功能介绍</h3><h4 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h4><p><code>.jsx</code> 和 <code>.tsx</code> 文件都可以开箱即用。JSX 的转译同样是通过 <a target="_blank" rel="noopener" href="https://esbuild.github.io/">esbuild</a>，默认为 React 16 形式，React 17 形式的 JSX 在 esbuild 中的支持请看 <a target="_blank" rel="noopener" href="https://github.com/evanw/esbuild/issues/334">这里</a>.</p>
<h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><p>导入<code>.css</code>文件将会把内容插入到<code>&lt;style&gt;</code>标签中，同时也带有HMR支持。也能够以字符串的形式检索处理后的、作为其模块默认导出的CSS</p>
<h4 id="import内联和重命名"><a href="#import内联和重命名" class="headerlink" title="@import内联和重命名"></a><strong><code>@import</code>内联和重命名</strong></h4><p>Vite通过<code>postcss-import</code>预配置支持了CSS<code>@import</code>内联，Vite的路径别名也遵从CSS<code>@import</code>。换言之，所有CSS url()引用，即使导入的文件在不同的目录中，也总是自动变基，以确保正确性。</p>
<p>Sass和Less文件也支持<code>@import</code>别名和URL重命名</p>
<h4 id="PostCSS"><a href="#PostCSS" class="headerlink" title="PostCSS"></a>PostCSS</h4><p>如果项目包含有效的PostCSS配置（任何受postcss-load-config支持的格式，例如postcss.config.js）,它将会自动应用于所有已导入的CSS。</p>
<h4 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h4><p>任何<code>.module.css</code>为后缀名的CSS文件都被认为是一个CSS modules文件。导入这样的文件会返回一个相应的模块对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* example.module.css</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">.red &#123;</span><br><span class="line">  <span class="attr">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> classes <span class="keyword">from</span> <span class="string">&#x27;./example.module.css&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).className = classes.red;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CSS Modules行为可以通过css.modules选项进行配置</span></span><br><span class="line"><span class="comment">// 如果 css.modules.localsConvention 设置开启了 camelCase 格式变量名转换（例如 localsConvention: &#x27;camelCaseOnly&#x27;）， 你还可以使用按名导入。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .apply-color -&gt; applyColor</span></span><br><span class="line"><span class="keyword">import</span> &#123; applyColor &#125; <span class="keyword">from</span> <span class="string">&#x27;./example.module.css&#x27;</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).className = applyColor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请注意 CSS modules localsConvention 默认是 camelCaseOnly - 例如一个名为 .foo-bar 的类会被暴露为 classes.fooBar。CSS modules 行为可以通过 css.modules option 选项配置。</span></span><br></pre></td></tr></table></figure>



<h4 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h4><p>Vite 也同时提供了对 <code>.scss</code>, <code>.sass</code>, <code>.less</code>, <code>.styl</code> 和 <code>.stylus</code> 文件的内置支持。</p>
<p>没有必要为他们安装特定的 vite 插件，但相应的预处理器依赖本身必须安装</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .scss and .sass</span></span><br><span class="line">npm install -D sass</span><br><span class="line"></span><br><span class="line"><span class="comment">// .less</span></span><br><span class="line">npm install -D less</span><br><span class="line"></span><br><span class="line"><span class="comment">// .styl and .stylus</span></span><br><span class="line">npm install -D stylus</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是用的是单文件组件，可以通过 &lt;style lang=&quot;sass&quot;&gt;（或其他与处理器）自动开启。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Vite 为 Sass 和 Less 改进了 @import 解析，因而 Vite 别名也同样受用，另外，url() 中的相对路径引用的，与根文件不同目录中的 Sass/Less 文件会自动变基以保证正确性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 由于与其 API 冲突，@import 别名和 URL 变基不支持 Stylus。</span></span><br><span class="line"><span class="comment">// 解决办法: 可以通过在文件扩展名前加上 .module 来结合使用 CSS modules 和预处理器，例如 style.module.scss。</span></span><br></pre></td></tr></table></figure>



<h4 id="JSON导入"><a href="#JSON导入" class="headerlink" title="JSON导入"></a>JSON导入</h4><p>支持JSON具名导入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入整个对象</span></span><br><span class="line"><span class="keyword">import</span> json <span class="keyword">from</span> <span class="string">&#x27;./example.json&#x27;</span></span><br><span class="line"><span class="comment">// 对一个根字段使用具名导入 - 有效运用 tree-shaking！</span></span><br><span class="line"><span class="keyword">import</span> &#123; field &#125; <span class="keyword">from</span> <span class="string">&#x27;./example.json&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h4><p>详情请见：<a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/assets.html">https://www.vitejs.net/guide/assets.html</a></p>
<p>public目录（目录默认是 <code>&lt;root&gt;/public</code>，但可以通过 <a target="_blank" rel="noopener" href="https://www.vitejs.net/config/#publicdir"><code>publicDir</code> 选项</a> 来配置。）</p>
<ul>
<li>不会被源码引用</li>
<li>必须保持原有文件名</li>
<li>不想为了获取URL而首先导入该资源</li>
</ul>
<blockquote>
<p>请注意：</p>
<ul>
<li>引入 public 中的资源永远应该使用根绝对路径 - 举个例子，public/icon.png 应该在源码中被引用为 /icon.png。</li>
<li><code>public</code> 中的资源不应该被 JavaScript 文件引用。</li>
</ul>
</blockquote>
<p><strong>支持URL导入</strong></p>
<p>导入一个静态资源会返回解析后的 URL：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如，imgUrl 在开发时会是 /img.png，在生产构建后会是 /assets/img.2d8efhg.png。</span></span><br><span class="line"><span class="keyword">import</span> imgUrl <span class="keyword">from</span> <span class="string">&#x27;./img.png&#x27;</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;hero-img&#x27;</span>).src = imgUrl</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为类似于 Webpack 的 file-loader。区别在于导入既可以使用绝对公共路径（基于开发期间的项目根路径），也可以使用相对路径。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// - url() 在 CSS 中的引用也以同样的方式处理。</span></span><br><span class="line"><span class="comment">// - 如果 Vite 使用了 Vue 插件，Vue SFC 模板中的资源引用都将自动转换为导入。</span></span><br><span class="line"><span class="comment">// - 常见的图像、媒体和字体文件类型被自动检测为资源。你可以使用 assetsInclude 选项 扩展内部列表。</span></span><br><span class="line"><span class="comment">// - 引用的资源作为构建资源图的一部分包括在内，将生成散列文件名，并可以由插件进行处理以进行优化。</span></span><br><span class="line"><span class="comment">// - 较小的资源体积小于 assetsInlineLimit 选项值 则会被内联为 base64 data URL。</span></span><br></pre></td></tr></table></figure>

<p>添加一些特殊的查询参数可以更改资源被引入的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式加载资源为一个 URL</span></span><br><span class="line"><span class="keyword">import</span> assetAsURL <span class="keyword">from</span> <span class="string">&#x27;./asset.js?url&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以字符串形式加载资源</span></span><br><span class="line"><span class="keyword">import</span> assetAsString <span class="keyword">from</span> <span class="string">&#x27;./shader.glsl?raw&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载为 Web Worker</span></span><br><span class="line"><span class="keyword">import</span> Worker <span class="keyword">from</span> <span class="string">&#x27;./worker.js?worker&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在构建时Web Worker 内联为 base64 字符串</span></span><br><span class="line"><span class="keyword">import</span> InlineWorker <span class="keyword">from</span> <span class="string">&#x27;./worker.js?worker&amp;inline&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="Glob-导入"><a href="#Glob-导入" class="headerlink" title="Glob 导入"></a>Glob 导入</h4><p>Vite 支持使用特殊的 <code>import.meta.glob</code> 函数从文件系统导入多个模块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> modules = <span class="keyword">import</span>.meta.glob(<span class="string">&#x27;./dir/*.js&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>以上将会被转译为下面的样子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite 生成的代码</span></span><br><span class="line"><span class="keyword">const</span> modules = &#123;</span><br><span class="line">  <span class="string">&#x27;./dir/foo.js&#x27;</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./dir/foo.js&#x27;</span>),</span><br><span class="line">  <span class="string">&#x27;./dir/bar.js&#x27;</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./dir/bar.js&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以遍历 <code>modules</code> 对象的 key 值来访问相应的模块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> path <span class="keyword">in</span> modules) &#123;</span><br><span class="line">  modules[path]().then(<span class="function">(<span class="params">mod</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(path, mod)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配到的文件将通过动态导入默认懒加载，并会在构建时分离为独立的 chunk。如果你倾向于直接引入所有的模块（例如依赖于这些模块中的副作用首先被应用），你可以使用 <code>import.meta.globEager</code> 代替：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> modules = <span class="keyword">import</span>.meta.globEager(<span class="string">&#x27;./dir/*.js&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>以上会被转译为下面的样子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite 生成的代码</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> __glob__0_0 <span class="keyword">from</span> <span class="string">&#x27;./dir/foo.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> __glob__0_1 <span class="keyword">from</span> <span class="string">&#x27;./dir/bar.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> modules = &#123;</span><br><span class="line">  <span class="string">&#x27;./dir/foo.js&#x27;</span>: __glob__0_0,</span><br><span class="line">  <span class="string">&#x27;./dir/bar.js&#x27;</span>: __glob__0_1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意：</p>
<ul>
<li>这只是一个 Vite 独有的功能而不是一个 Web 或 ES 标准</li>
<li>该 Glob 模式会被当成导入标识符：必须是相对路径（以 <code>./</code> 开头，相对于项目根目录解析），从依赖中来的 Glob 不被支持。</li>
<li>Glob 导入只能使用默认导入（无法使用按名导入，也无法使用 <code>import * as ...</code>）。</li>
</ul>
<h3 id="5-构建优化"><a href="#5-构建优化" class="headerlink" title="5. 构建优化"></a>5. 构建优化</h3><blockquote>
<p>下面所罗列的功能会自动应用为构建过程的一部分，没有必要在配置中显式地声明，除非你想禁用它们。</p>
</blockquote>
<h4 id="动态导入-Polyfill"><a href="#动态导入-Polyfill" class="headerlink" title="动态导入 Polyfill"></a><a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/features.html#%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5-polyfill">动态导入 Polyfill</a></h4><p>Vite 使用 ES 动态导入作为代码分割的断点。生成的代码也会使用动态导入来加载异步 chunk。然而浏览器对原生 ESM 动态导入的功能落地比对 <code>type=&quot;module&quot;</code> script 块支持要晚，它们两个功能之间存在着浏览器兼容性差异。Vite 自动会生成一个轻量级的 <a target="_blank" rel="noopener" href="https://github.com/GoogleChromeLabs/dynamic-import-polyfill">动态导入 polyfill</a> 来抹平二者差异。</p>
<p>如果你确定你的构建目标只有支持原生动态导入的浏览器，你可以通过 <a target="_blank" rel="noopener" href="https://www.vitejs.net/config/#build-polyfilldynamicimport"><code>build.polyfillDynamicImport</code></a> 显式地禁用这个功能。</p>
<h4 id="CSS-代码分割"><a href="#CSS-代码分割" class="headerlink" title="CSS 代码分割"></a><a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/features.html#css-%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2">CSS 代码分割</a></h4><p>Vite 会自动地将一个异步 chunk 模块中使用到的 CSS 代码抽取出来并为其生成一个单独的文件。这个 CSS 文件将在该异步 chunk 加载完成时自动通过一个 <code>&lt;link&gt;</code> 标签载入，该异步 chunk 会保证只在 CSS 加载完毕后再执行，避免发生 [FOUC](<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Flash_of_unstyled_content#:~:text=A">https://en.wikipedia.org/wiki/Flash_of_unstyled_content#:~:text=A</a> flash of unstyled content,before all information is retrieved.) 。</p>
<p>如果你更倾向于将所有的 CSS 抽取到一个文件中，你可以通过设置 <a target="_blank" rel="noopener" href="https://www.vitejs.net/config/#build-csscodesplit"><code>build.cssCodeSplit</code></a> 为 <code>false</code> 来禁用 CSS 代码分割。</p>
<h4 id="预加载指令生成"><a href="#预加载指令生成" class="headerlink" title="预加载指令生成"></a><a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/features.html#%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%8C%87%E4%BB%A4%E7%94%9F%E6%88%90">预加载指令生成</a></h4><p>Vite 会为入口 chunk 和它们在打包出的 HTML 中的直接引入自动生成 <code>&lt;link rel=&quot;modulepreload&quot;&gt;</code> 指令。</p>
<h4 id="异步-Chunk-加载优化"><a href="#异步-Chunk-加载优化" class="headerlink" title="异步 Chunk 加载优化"></a><a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/features.html#%E5%BC%82%E6%AD%A5-chunk-%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96">异步 Chunk 加载优化</a></h4><p>在实际项目中，Rollup 通常会生成 “共用” chunk —— 被两个或以上的其他 chunk 共享的 chunk。与动态导入相结合，会很容易出现下面这种场景：</p>
<p><img src="./graph.8f2f36b7.png" alt="graph.8f2f36b7"></p>
<p>在无优化的情境下，当异步 chunk <code>A</code> 被导入时，浏览器将必须请求和解析 <code>A</code>，然后它才能弄清楚它首先需要那个共用 chunk <code>C</code>。这会导致额外的网络往返：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry ---&gt; A ---&gt; C</span><br></pre></td></tr></table></figure>

<p>Vite 将使用一个预加载步骤自动重写代码，来分割动态导入调用，因而当 <code>A</code> 被请求时，<code>C</code> 也将 <strong>同时</strong> 被获取到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry ---&gt; (A + C)</span><br></pre></td></tr></table></figure>

<p><code>C</code> 也可能有更深的导入，在未优化的场景中，这甚至会导致额外网络往返。Vite 的优化将跟踪所有的直接导入，无论导入深度如何，都完全消除不必要的往返。</p>
<h3 id="6-构建生产版本"><a href="#6-构建生产版本" class="headerlink" title="6. 构建生产版本"></a>6. 构建生产版本</h3><p>当需要将应用程序部署到生产环境时，只需运行 <code>vite build</code> 命令。默认情况下，它使用 <code>&lt;root&gt;/index.html</code> 作为构建入口点，并生成一个适合通过静态部署的应用程序包。</p>
<h4 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a><a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/build.html#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7">浏览器兼容性</a></h4><p>生产版本假设浏览器对 <a target="_blank" rel="noopener" href="https://caniuse.com/es6-module-dynamic-import">原生 ES 模块动态导入</a> 有基本支持。默认情况下，所有代码构建都会以 <a target="_blank" rel="noopener" href="https://caniuse.com/es6-module">支持原生 ESM script 标签的浏览器</a> 为目标。</p>
<p>一个轻量级的 <a target="_blank" rel="noopener" href="https://github.com/GoogleChromeLabs/dynamic-import-polyfill">动态导入 polyfill</a> 也会同时自动注入。</p>
<p>你也可以通过 <a target="_blank" rel="noopener" href="https://www.vitejs.net/config/#build-target"><code>build.target</code> 配置项</a> 指定构建目标，最低支持 <code>es2015</code>。</p>
<ul>
<li>Chrome &gt;=61</li>
<li>Firefox &gt;=60</li>
<li>Safari &gt;=11</li>
<li>Edge &gt;=16</li>
</ul>
<p>请注意，默认情况下 Vite 只处理语法转译，并 <strong>不默认包含任何 polyfill</strong>。你可以前往 <a target="_blank" rel="noopener" href="https://polyfill.io/v3/">Polyfill.io</a> 查看，这是一个基于用户浏览器 User-Agent 字符串自动生成 polyfill 包的服务。</p>
<p>传统浏览器可以通过插件 <a target="_blank" rel="noopener" href="https://github.com/vitejs/vite/tree/main/packages/plugin-legacy">@vitejs/plugin-legacy</a> 来支持，它将自动生成传统版本的 chunk 和其相应 ES 语言特性方面的 polyfill。兼容版的 chunk 只会在不支持原生 ESM 的浏览器中有按需加载。</p>
<h4 id="公共基础路径"><a href="#公共基础路径" class="headerlink" title="公共基础路径"></a><a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/build.html#%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%B7%AF%E5%BE%84">公共基础路径</a></h4><ul>
<li>相关内容：<a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/assets.html">静态资源处理</a></li>
</ul>
<p>如果你正在嵌套的公共路径下部署项目，可以简单指定一个 <a target="_blank" rel="noopener" href="https://www.vitejs.net/config/#base"><code>build.base</code> 配置项</a> 然后所有资源的路径都将据此重写。这个选项也可以通过命令行参数指定，例如 <code>vite build --base=/my/public/path/</code>。</p>
<p>由 JS 导入的资源路径，CSS 中的 <code>url()</code> 引用，和 <code>.html</code> 文件中的资源引用在构建过程中都会自动调整以适配此选项。</p>
<p>例外情况是需要动态连接 url。在这种情况下，你可以使用全局注入的 <code>import.meta.env.BASE_URL</code> 变量，它将是 公共基础路径。注意这个变量在构建中是被静态替换的所以它必须是原本的样子（例如 <code>import.meta.env[&#39;BASE_URL&#39;]</code> 是无效的）</p>
<h4 id="自定义构建"><a href="#自定义构建" class="headerlink" title="自定义构建"></a><a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/build.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA">自定义构建</a></h4><p>构建过程可以通过多种 <a target="_blank" rel="noopener" href="https://www.vitejs.net/config/#build-options">构建配置选项</a> 来自定义。特别地，你可以通过 <code>build.rollupOptions</code> 直接调整底层的 <a target="_blank" rel="noopener" href="https://rollupjs.org/guide/en/#big-list-of-options">Rollup 选项</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">rollupOptions</span>: &#123;</span><br><span class="line">      <span class="comment">// https://rollupjs.org/guide/en/#big-list-of-options</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，你可以使用仅在构建期间应用的插件来指定多个 Rollup 输出。</p>
<h4 id="多页面应用模式"><a href="#多页面应用模式" class="headerlink" title="多页面应用模式"></a><a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/build.html#%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F">多页面应用模式</a></h4><p>假设你有下面这样的项目文件结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── package.json</span><br><span class="line">├── vite.config.js</span><br><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">└── nested</span><br><span class="line">    ├── index.html</span><br><span class="line">    └── nested.js</span><br></pre></td></tr></table></figure>

<p>在开发中，简单地导航或链接到 <code>/nested/</code> - 将会按预期工作，就如同一个正常的静态文件服务器。</p>
<p>在构建中，你要做的只有指定多个 <code>.html</code> 文件作为入口点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">rollupOptions</span>: &#123;</span><br><span class="line">      <span class="attr">input</span>: &#123;</span><br><span class="line">        <span class="attr">main</span>: resolve(__dirname, <span class="string">&#x27;index.html&#x27;</span>),</span><br><span class="line">        <span class="attr">nested</span>: resolve(__dirname, <span class="string">&#x27;nested/index.html&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="库模式"><a href="#库模式" class="headerlink" title="库模式"></a><a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/build.html#%E5%BA%93%E6%A8%A1%E5%BC%8F">库模式</a></h4><p>当你开发面向浏览器的库时，你可能会将大部分时间花在该库的测试/演示页面上。使用 Vite，你可以使用 <code>index.html</code> 来获得如丝般顺滑的开发体验。</p>
<p>当需要构建你的库用于发布时，请使用 <a target="_blank" rel="noopener" href="https://www.vitejs.net/config/#build-lib"><code>build.lib</code> 配置项</a>，请确保将你不想打包进你库中的依赖进行外部化，例如 <code>vue</code> 或 <code>react</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">lib</span>: &#123;</span><br><span class="line">      <span class="attr">entry</span>: path.resolve(__dirname, <span class="string">&#x27;lib/main.js&#x27;</span>),</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;MyLib&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">rollupOptions</span>: &#123;</span><br><span class="line">      <span class="comment">// 请确保外部化那些你的库中不需要的依赖</span></span><br><span class="line">      <span class="attr">external</span>: [<span class="string">&#x27;vue&#x27;</span>],</span><br><span class="line">      <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">// 在 UMD 构建模式下为这些外部化的依赖提供一个全局变量</span></span><br><span class="line">        <span class="attr">globals</span>: &#123;</span><br><span class="line">          <span class="attr">vue</span>: <span class="string">&#x27;Vue&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 <code>vite build</code> 配合如上配置将会使用一套 Rollup 预设，为发行该库提供两种构建格式：<code>es</code> 和 <code>umd</code>（在 <code>build.lib</code> 中配置的）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vite build</span><br><span class="line">building <span class="keyword">for</span> production...</span><br><span class="line">[write] my-lib.es.js <span class="number">0.</span>08kb, <span class="attr">brotli</span>: <span class="number">0.</span>07kb</span><br><span class="line">[write] my-lib.umd.js <span class="number">0.</span>30kb, <span class="attr">brotli</span>: <span class="number">0.</span>16kb</span><br></pre></td></tr></table></figure>

<p>推荐你的库中 <code>package.json</code> 的采用如下格式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;my-lib&quot;</span>,</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: [<span class="string">&quot;dist&quot;</span>],</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./dist/my-lib.umd.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;module&quot;</span>: <span class="string">&quot;./dist/my-lib.es.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./dist/my-lib.es.js&quot;</span>,</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./dist/my-lib.umd.js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-环境变量与模式"><a href="#7-环境变量与模式" class="headerlink" title="7. 环境变量与模式"></a>7. 环境变量与模式</h3><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a><a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/env-and-mode.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a></h4><p>Vite 在一个特殊的 <strong><code>import.meta.env</code></strong> 对象上暴露环境变量。这里有一些普遍适用的内建变量：</p>
<ul>
<li><strong><code>import.meta.env.MODE</code></strong>: <code>string</code> 应用运行基于的 <a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/env-and-mode.html#modes">模式</a>。</li>
<li><strong><code>import.meta.env.BASE_URL</code></strong>: <code>string</code> 应用正被部署在的 base URL。它由 <a target="_blank" rel="noopener" href="https://www.vitejs.net/config/#base"><code>base</code> 配置项</a> 决定。</li>
<li><strong><code>import.meta.env.PROD</code></strong>: <code>boolean</code> 应用是否运行在生产环境</li>
<li><strong><code>import.meta.env.DEV</code></strong>: <code>boolean</code> 应用是否运行在开发环境 (永远与 <code>import.meta.env.PROD</code> 相反)</li>
</ul>
<h4 id="生产环境替换"><a href="#生产环境替换" class="headerlink" title="生产环境替换"></a><a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/env-and-mode.html#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%9B%BF%E6%8D%A2">生产环境替换</a></h4><p>在生产环境中，这些环境变量会在构建时被静态替换，因此请在引用它们时使用完全静态的字符串。动态的 key 将无法生效。例如，动态 key 取值 <code>import.meta.env[key]</code> 是无效的。</p>
<p>它还将替换出现在 JavaScript 和 Vue 模板中的字符串。这应该是比较罕见的情况，但它可能是不小心为之。有一些方法可以避免这个问题:</p>
<ul>
<li>对于 JavaScript 字符串，你可以在相应位置上使用一个 unicode 序列值，例如： <code>&#39;import.meta\u200b.env.MODE&#39;</code>。</li>
<li>对于 Vue 模板或其他编译到 JavaScript 字符串的 HTML，你可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/wbr">`` 标签</a>，例如：<code>import.meta.&lt;wbr&gt;env.MODE</code>。</li>
</ul>
<h4 id="env-文件"><a href="#env-文件" class="headerlink" title=".env 文件"></a><a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/env-and-mode.html#env-%E6%96%87%E4%BB%B6"><code>.env</code> 文件</a></h4><p>Vite 使用 <a target="_blank" rel="noopener" href="https://github.com/motdotla/dotenv">dotenv</a> 在你的项目根目录下从以下文件加载额外的环境变量:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.env                <span class="comment">// 所有情况下都会加载</span></span><br><span class="line">.env.local          <span class="comment">// 所有情况下都会加载，但会被 git 忽略</span></span><br><span class="line">.env.[mode]         <span class="comment">// 只在指定模式下加载</span></span><br><span class="line">.env.[mode].local   <span class="comment">// 只在指定模式下加载，但会被 git 忽略</span></span><br></pre></td></tr></table></figure>

<p>加载的环境变量也会通过 <code>import.meta.env</code> 暴露给客户端源码。</p>
<p>为了防止意外地将一些环境变量泄漏到客户端，只有以 <code>VITE_</code> 为前缀的变量才会暴露给经过 vite 处理的代码。例如下面这个文件中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB_PASSWORD=foobar</span><br><span class="line">VITE_SOME_KEY=<span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>只有 <code>VITE_SOME_KEY</code> 会被暴露为 <code>import.meta.env.VITE_SOME_KEY</code> 提供给客户端源码，而 <code>DB_PASSWORD</code> 则不会。</p>
<p>安全警告</p>
<ul>
<li><code>.env.*.local</code> 文件应是本地的，可以包含敏感变量。你应该加上 <code>.local</code> 到你的 <code>.gitignore</code> 以避免他们被检出到 git。</li>
<li>由于暴露在 Vite 源码中的任何变量都将最终出现在客户端包中，<code>VITE_*</code> 变量应该不包含任何敏感信息。</li>
</ul>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a><a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/env-and-mode.html#%E6%A8%A1%E5%BC%8F">模式</a></h4><p>默认情况下，开发服务器 (<code>serve</code> 命令) 运行在 <code>development</code> （开发）模式，而 <code>build</code> 命令运行在 <code>production</code> （生产）模式。</p>
<p>这意味着当执行 <code>vite build</code> 时，它会自动加载 <code>.env.production</code> 中可能存在的环境变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .env.production</span></span><br><span class="line">VITE_APP_TITLE=My App</span><br></pre></td></tr></table></figure>

<p>在你的应用中，你可以使用 <code>import.meta.env.VITE_APP_TITLE</code> 作为渲染标题。</p>
<p>然而重要的是，要理解<strong>模式</strong>是一个更广泛的概念，而不仅仅是开发和生产。一个典型的例子是，你可能希望有一个 “staging” 模式，它应该具有类似于生产的行为，但环境变量与生产环境略有不同。</p>
<p>你可以通过传递 <code>--mode</code> 选项标志来覆盖命令使用的默认模式。例如，如果你想为我们假设的 staging 模式构建应用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vite build --mode staging</span><br></pre></td></tr></table></figure>

<p>为了使应用实现预期行为，我们还需要一个 <code>.env.staging</code> 文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .env.staging</span></span><br><span class="line">NODE_ENV=production</span><br><span class="line">VITE_APP_TITLE=My App (staging)</span><br></pre></td></tr></table></figure>

<p>现在，staging 应用应该具有类似于生产的行为，但显示的标题与生产环境不同。</p>
<h3 id="8-服务端渲染（SSR）"><a href="#8-服务端渲染（SSR）" class="headerlink" title="8. 服务端渲染（SSR）"></a>8. 服务端渲染（SSR）</h3><p><strong>PS：SSR 支持还处于试验阶段，你可能会遇到 bug 和不受支持的用例</strong></p>
<p>详情请见：<a target="_blank" rel="noopener" href="https://www.vitejs.net/guide/ssr.html">https://www.vitejs.net/guide/ssr.html</a></p>
<h3 id="9-其他配置请见官网指南"><a href="#9-其他配置请见官网指南" class="headerlink" title="9. 其他配置请见官网指南"></a>9. 其他配置请见官网指南</h3><p><a target="_blank" rel="noopener" href="https://www.vitejs.net/config/#root">https://www.vitejs.net/config/#root</a></p>
<h2 id="四、Vite实现的原理是什么？"><a href="#四、Vite实现的原理是什么？" class="headerlink" title="四、Vite实现的原理是什么？"></a>四、Vite实现的原理是什么？</h2><p>上面第二点我们简单说明了Vite出现的原因和打包构建过程。这里我们来详细讲解一下Vite到底做了哪些事？</p>
<p>首先，我们按照上面的操作创建一个新的项目，运行<code>npm run dev</code>启动项目，然后我们在浏览器打开页面，打开浏览器控制台，刷新。</p>
<p>这个时候，我们可以看到</p>
<p><img src="./vite-network.png" alt="vite-network"></p>
<ol>
<li><p>重写引入模块路径前面加上/node_modules/，重写后浏览器会再次发送请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原main.jsx文件：</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过vite构建后请求的main.jsx文件</span></span><br><span class="line"><span class="keyword">import</span> __vite__cjsImport0_react <span class="keyword">from</span> <span class="string">&quot;/node_modules/.vite/react.js?v=4b8607c0&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> React = __vite__cjsImport0_react.__esModule ? __vite__cjsImport0_react.default : __vite__cjsImport0_react;</span><br><span class="line"><span class="keyword">import</span> __vite__cjsImport1_reactDom <span class="keyword">from</span> <span class="string">&quot;/node_modules/.vite/react-dom.js?v=4b8607c0&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> ReactDOM = __vite__cjsImport1_reactDom.__esModule ? __vite__cjsImport1_reactDom.default : __vite__cjsImport1_reactDom;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;/src/index.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;/src/App.jsx&quot;</span>;</span><br><span class="line">ReactDOM.render(<span class="comment">/* @__PURE__ */</span></span><br><span class="line">React.createElement(React.StrictMode, <span class="literal">null</span>, <span class="comment">/* @__PURE__ */</span></span><br><span class="line">React.createElement(App, <span class="literal">null</span>)), <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnZpbi9EZXNrdG9wL3ZpdGUvbXktdml0ZS1hcHAvc3JjL21haW4uanN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nXG5pbXBvcnQgJy4vaW5kZXguY3NzJ1xuaW1wb3J0IEFwcCBmcm9tICcuL0FwcCdcblxuUmVhY3RET00ucmVuZGVyKFxuICA8UmVhY3QuU3RyaWN0TW9kZT5cbiAgICA8QXBwIC8+XG4gIDwvUmVhY3QuU3RyaWN0TW9kZT4sXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290JylcbilcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQSxTQUFTLE9BQ1Asb0NBQUMsTUFBTSxZQUFQLE1BQ0Usb0NBQUMsS0FBRCxRQUVGLFNBQVMsZUFBZTsiLCJuYW1lcyI6W119</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="五、使用Vite出现的问题"><a href="#五、使用Vite出现的问题" class="headerlink" title="五、使用Vite出现的问题"></a>五、使用Vite出现的问题</h2><h2 id="六、Vite示例"><a href="#六、Vite示例" class="headerlink" title="六、Vite示例"></a>六、Vite示例</h2><h2 id="七、本文出现的各种技术的官网地址："><a href="#七、本文出现的各种技术的官网地址：" class="headerlink" title="七、本文出现的各种技术的官网地址："></a>七、本文出现的各种技术的官网地址：</h2><p>Vite: <a target="_blank" rel="noopener" href="https://www.vitejs.net/">https://www.vitejs.net/</a></p>
<p>Webpack: <a target="_blank" rel="noopener" href="https://webpack.docschina.org/">https://webpack.docschina.org/</a></p>
<p>esbuild: <a target="_blank" rel="noopener" href="https://esbuild.github.io/">https://esbuild.github.io/</a></p>
<p>Rollup: <a target="_blank" rel="noopener" href="https://www.rollupjs.com/">https://www.rollupjs.com/</a></p>
<p>Babel: <a target="_blank" rel="noopener" href="https://www.babeljs.cn/">https://www.babeljs.cn/</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Arvin Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hello-hc.github.io/2021/06/04/vite/vite/">https://hello-hc.github.io/2021/06/04/vite/vite/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hello-hc.github.io" target="_blank">Arvin's Blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/images/img_05.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/01/React-Router/"><img class="prev-cover" src="/images/9.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">React-Router</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/03/taro-study/"><img class="next-cover" src="/images/img_03.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Taro Study</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Arvin Huang</div><div class="author-info__description">仅作为本人学习使用</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hello-hc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hello-hc" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/2867712953@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Vite%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">一、Vite是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0Vite%EF%BC%8C%E6%8D%A2%E8%A8%80%E4%B9%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">二、为什么会出现Vite，换言之，为什么会出现打包构建工具？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Vite%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">三、如何使用Vite？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA"><span class="toc-number">3.1.</span> <span class="toc-text">1. 项目搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%AD%E5%BB%BAVite%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">3.1.1.</span> <span class="toc-text">搭建Vite项目的方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.2.</span> <span class="toc-text">2. 项目文件及目录介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82"><span class="toc-number">3.3.</span> <span class="toc-text">3. 项目需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.4.</span> <span class="toc-text">4. 功能介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSX"><span class="toc-number">3.4.1.</span> <span class="toc-text">JSX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS"><span class="toc-number">3.4.2.</span> <span class="toc-text">CSS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#import%E5%86%85%E8%81%94%E5%92%8C%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-number">3.4.3.</span> <span class="toc-text">@import内联和重命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PostCSS"><span class="toc-number">3.4.4.</span> <span class="toc-text">PostCSS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-Modules"><span class="toc-number">3.4.5.</span> <span class="toc-text">CSS Modules</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">3.4.6.</span> <span class="toc-text">CSS预处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON%E5%AF%BC%E5%85%A5"><span class="toc-number">3.4.7.</span> <span class="toc-text">JSON导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86"><span class="toc-number">3.4.8.</span> <span class="toc-text">静态资源处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Glob-%E5%AF%BC%E5%85%A5"><span class="toc-number">3.4.9.</span> <span class="toc-text">Glob 导入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9E%84%E5%BB%BA%E4%BC%98%E5%8C%96"><span class="toc-number">3.5.</span> <span class="toc-text">5. 构建优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5-Polyfill"><span class="toc-number">3.5.1.</span> <span class="toc-text">动态导入 Polyfill</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2"><span class="toc-number">3.5.2.</span> <span class="toc-text">CSS 代码分割</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%8C%87%E4%BB%A4%E7%94%9F%E6%88%90"><span class="toc-number">3.5.3.</span> <span class="toc-text">预加载指令生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-Chunk-%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96"><span class="toc-number">3.5.4.</span> <span class="toc-text">异步 Chunk 加载优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9E%84%E5%BB%BA%E7%94%9F%E4%BA%A7%E7%89%88%E6%9C%AC"><span class="toc-number">3.6.</span> <span class="toc-text">6. 构建生产版本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">3.6.1.</span> <span class="toc-text">浏览器兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%B7%AF%E5%BE%84"><span class="toc-number">3.6.2.</span> <span class="toc-text">公共基础路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA"><span class="toc-number">3.6.3.</span> <span class="toc-text">自定义构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.4.</span> <span class="toc-text">多页面应用模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%93%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.5.</span> <span class="toc-text">库模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">7. 环境变量与模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">3.7.1.</span> <span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%9B%BF%E6%8D%A2"><span class="toc-number">3.7.2.</span> <span class="toc-text">生产环境替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#env-%E6%96%87%E4%BB%B6"><span class="toc-number">3.7.3.</span> <span class="toc-text">.env 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.7.4.</span> <span class="toc-text">模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%88SSR%EF%BC%89"><span class="toc-number">3.8.</span> <span class="toc-text">8. 服务端渲染（SSR）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE%E8%AF%B7%E8%A7%81%E5%AE%98%E7%BD%91%E6%8C%87%E5%8D%97"><span class="toc-number">3.9.</span> <span class="toc-text">9. 其他配置请见官网指南</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Vite%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">四、Vite实现的原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BD%BF%E7%94%A8Vite%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">五、使用Vite出现的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Vite%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">六、Vite示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%9C%AC%E6%96%87%E5%87%BA%E7%8E%B0%E7%9A%84%E5%90%84%E7%A7%8D%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%98%E7%BD%91%E5%9C%B0%E5%9D%80%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">七、本文出现的各种技术的官网地址：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/08/29/TypeScript/" title="TypeScript总结（正在继续完善中...）"><img src="/images/10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TypeScript总结（正在继续完善中...）"/></a><div class="content"><a class="title" href="/2021/08/29/TypeScript/" title="TypeScript总结（正在继续完善中...）">TypeScript总结（正在继续完善中...）</a><time datetime="2021-08-29T15:01:41.702Z" title="发表于 2021-08-29 23:01:41">2021-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/28/react-big-calendar/react-big-calendar/" title="ReactBigCalendar的简单使用"><img src="/images/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ReactBigCalendar的简单使用"/></a><div class="content"><a class="title" href="/2021/08/28/react-big-calendar/react-big-calendar/" title="ReactBigCalendar的简单使用">ReactBigCalendar的简单使用</a><time datetime="2021-08-28T06:27:55.658Z" title="发表于 2021-08-28 14:27:55">2021-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/04/React-Redux/" title="Redux"><img src="/images/8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redux"/></a><div class="content"><a class="title" href="/2021/07/04/React-Redux/" title="Redux">Redux</a><time datetime="2021-07-04T06:46:11.446Z" title="发表于 2021-07-04 14:46:11">2021-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/01/React-Router/" title="React-Router"><img src="/images/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React-Router"/></a><div class="content"><a class="title" href="/2021/07/01/React-Router/" title="React-Router">React-Router</a><time datetime="2021-07-01T13:53:55.473Z" title="发表于 2021-07-01 21:53:55">2021-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/04/vite/vite/" title="Vite 初探"><img src="/images/img_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vite 初探"/></a><div class="content"><a class="title" href="/2021/06/04/vite/vite/" title="Vite 初探">Vite 初探</a><time datetime="2021-06-04T02:00:55.000Z" title="发表于 2021-06-04 10:00:55">2021-06-04</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient( 135deg,"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Arvin Huang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>